//go:build ignore

// ⚠️  WARNING: This example uses the OLD API
//
// This example has not been migrated to the new Pulumi-aligned API yet.
// It demonstrates error handling concepts but uses deprecated patterns.
//
// For migration guidance, see: docs/guides/typed-context-migration.md
// For new API patterns, see: examples/07_basic_workflow.go
//
// OLD patterns used in this file:
// - defer stigmer.Complete() → should use stigmer.Run(func(ctx) {...})
// - HttpCallTask() with WithHTTPGet() → should use wf.HttpGet(name, uri)
// - FieldRef() → should use task.Field(fieldName)
// - .ThenRef(task) → should use implicit dependencies via field references
//
// Package examples demonstrates error handling using TRY/CATCH tasks.
package main

import (
	"log"

	"github.com/leftbin/stigmer-sdk/go/stigmer"
	"github.com/leftbin/stigmer-sdk/go/workflow"
)

// This example demonstrates error handling using TRY tasks with modern type-safe API patterns.
//
// The workflow:
// 1. Attempts a risky operation (HTTP call)
// 2. Catches HTTP/gRPC errors and handles them with retry logic
// 3. Catches validation errors separately (non-retryable)
// 4. Logs errors and continues execution with graceful degradation
//
// Modern patterns demonstrated:
// - Type-safe error matchers (CatchHTTPErrors, CatchGRPCErrors) instead of raw strings
// - Type-safe error field accessors (ErrorMessage, ErrorCode) instead of "${err.field}" strings
// - Arithmetic expression helpers (Increment, Decrement) for common patterns
// - Type-safe duration builders (Seconds, Minutes, Hours, Days) instead of "5s" strings
// - Platform error types that match workflow-runner backend
// - Condition builders (And, LessThan) instead of raw expression strings
// - Type-safe task references instead of string names
// - "Define first, reference later" for compile-time validation
// - WithCaseRef/WithDefaultRef for refactoring safety
//
// Error Type Contract:
// The error types caught in this example (e.g., "CallHTTP error", "CallGRPC error")
// are generated by the Stigmer workflow runner backend. They are NOT arbitrary strings.
// Using workflow.CatchHTTPErrors() ensures we match the actual platform error types.
func main() {
	defer stigmer.Complete()

	// Task 1: Initialize using type-safe setters
	initTask := workflow.SetTask("initialize",
		workflow.SetInt("retryCount", 0),
		workflow.SetInt("maxRetries", 3),
	)

	// Define tasks first for type-safe references (modern pattern)
	// This enables refactoring, autocomplete, and compile-time validation

	// Retry task (defined early for forward reference)
	retryTask := workflow.SetTask("retry",
		workflow.SetVar("retryCount", workflow.Increment("retryCount")), // ✅ Type-safe increment
	).End()

	// Wait before retry task
	waitBeforeRetryTask := workflow.WaitTask("waitBeforeRetry",
		workflow.WithDuration(workflow.Seconds(5)), // ✅ Type-safe duration
	).End()

	// Log error task
	// Using JSONPlaceholder - a free fake REST API for testing and prototyping
	logErrorTask := workflow.HttpCallTask("logError",
		workflow.WithHTTPPost(), // Type-safe HTTP method
		workflow.WithURI("https://jsonplaceholder.typicode.com/posts"),
		workflow.WithBody(map[string]any{
			"title":        "Error Log",
			"errorType":    workflow.VarRef("errorType"),
			"errorMessage": workflow.VarRef("errorMessage"),
			"retryCount":   workflow.VarRef("retryCount"),
		}),
	).End()

	// Check retry task using modern condition builders
	checkRetryTask := workflow.SwitchTask("checkRetry",
		// Modern API: Use condition builders instead of raw expression strings
		// Old: "${shouldRetry && retryCount < maxRetries}"
		// New: And(Field("shouldRetry"), LessThan(Field("retryCount"), Field("maxRetries")))
		workflow.WithCaseRef(
			workflow.And(
				workflow.Field("shouldRetry"), // shouldRetry is true
				workflow.LessThan(workflow.Field("retryCount"), workflow.Field("maxRetries")), // retryCount < maxRetries
			),
			retryTask, // Type-safe reference
		),
		workflow.WithDefaultRef(logErrorTask), // Type-safe reference
	).End()

	// Task 2: Try risky operation with error handling using type-safe error matchers
	// Now using task references for flow control AND type-safe error matching
	// Using JSONPlaceholder - a free fake REST API for testing and prototyping
	attemptDataFetchTask := workflow.TryTask("attemptDataFetch",
		// Try block - risky operation
		workflow.WithTry(
			workflow.HttpCallTask("fetchData",
				workflow.WithHTTPGet(), // Type-safe HTTP method
				workflow.WithURI("https://jsonplaceholder.typicode.com/posts/1"),
				workflow.WithTimeout(10),
			).ExportAll(),
		),

		// Catch HTTP errors using type-safe error matcher
		// Modern: WithCatchTyped + CatchHTTPErrors() for discoverability
		// Platform error type: "CallHTTP error" (from workflow runner backend)
		workflow.WithCatchTyped(
			workflow.CatchHTTPErrors(), // ✅ Type-safe, matches actual platform error
			"httpErr",                  // Bind error to this variable
			workflow.SetTask("handleHTTPError",
				workflow.SetString("errorType", "http"),
				workflow.SetVar("errorMessage", workflow.ErrorMessage("httpErr")), // ✅ Type-safe error field access
				workflow.SetBool("shouldRetry", true),
			).ThenRef(checkRetryTask), // Modern: ThenRef with task reference
		),

		// Catch gRPC errors (if you have gRPC calls)
		// Platform error type: "CallGRPC error"
		workflow.WithCatchTyped(
			workflow.CatchGRPCErrors(),
			"grpcErr",
			workflow.SetTask("handleGRPCError",
				workflow.SetString("errorType", "grpc"),
				workflow.SetVar("errorMessage", workflow.ErrorMessage("grpcErr")), // ✅ Type-safe error field access
				workflow.SetBool("shouldRetry", true),
			).ThenRef(checkRetryTask),
		),

		// Catch validation errors
		// Platform error type: "Validation"
		workflow.WithCatchTyped(
			workflow.CatchValidationErrors(),
			"validationErr",
			workflow.SetTask("handleValidationError",
				workflow.SetString("errorType", "validation"),
				workflow.SetVar("errorMessage", workflow.ErrorMessage("validationErr")), // ✅ Type-safe error field access
				workflow.SetBool("shouldRetry", false),
			).ThenRef(logErrorTask), // Non-retryable - go straight to logging
		),

		// Catch all other errors using wildcard
		// Modern: CatchAny() instead of raw "*" string
		workflow.WithCatchTyped(
			workflow.CatchAny(), // ✅ Clear intent: catch everything else
			"err",
			workflow.SetTask("handleUnknownError",
				workflow.SetString("errorType", "unknown"),
				workflow.SetVar("errorMessage", workflow.ErrorMessage("err")), // ✅ Type-safe error field access
				workflow.SetBool("shouldRetry", false),
			).ThenRef(logErrorTask), // Modern: ThenRef with task reference
		),
	).End()

	// Connect retry flow - creates a loop that retries failed operations
	//
	// Flow diagram:
	//   attemptDataFetch (try HTTP call)
	//        ↓ (on error)
	//   handleError (catch block - set error variables, shouldRetry=true)
	//        ↓
	//   checkRetry (switch: shouldRetry && retryCount < maxRetries?)
	//        ↓ YES                           ↓ NO
	//   retry (increment count)          logError (record failure)
	//        ↓
	//   waitBeforeRetry (5 second delay)
	//        ↓
	//   attemptDataFetch (retry the operation) ← LOOP BACK
	retryTask.ThenRef(waitBeforeRetryTask)
	waitBeforeRetryTask.ThenRef(attemptDataFetchTask)
	initTask.ThenRef(attemptDataFetchTask)

	// Final task: Continue with graceful degradation using type-safe setters
	// This task runs after all error handling is complete (success or max retries exceeded)
	// Note: No .Then() or .ThenRef() - the workflow ends here
	gracefulDegradationTask := workflow.SetTask("gracefulDegradation",
		workflow.SetString("status", "partial_failure"),
		workflow.SetString("message", "Operation failed but workflow continued"),
	)

	// Create workflow with all tasks
	wf, err := workflow.New(
		workflow.WithNamespace("data-processing"),
		workflow.WithName("resilient-api-call"),
		workflow.WithVersion("1.0.0"),
		workflow.WithDescription("Workflow with comprehensive error handling"),
		workflow.WithTasks(initTask, attemptDataFetchTask, checkRetryTask, retryTask, waitBeforeRetryTask, logErrorTask, gracefulDegradationTask),
	)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Created error handling workflow: %s", wf)
}
